import jsPDF from "jspdf";
import { PDF_THEMES } from "../constants";
import type {
  TechnicalPortfolioData,
  TechnicalPortfolioOptions,
} from "../types";

export function generateTechnicalPortfolioPDF(
  data: TechnicalPortfolioData,
  options: TechnicalPortfolioOptions = {}
): jsPDF {
  const opts = {
    theme: options.theme || "corporate",
    layout: options.layout || "single",
    includeCodeExamples: options.includeCodeExamples ?? true,
    includeChallenges: options.includeChallenges ?? true,
    includeArchitecture: options.includeArchitecture ?? true,
    maxProjects: options.maxProjects || 5,
    maxCodeExamples: options.maxCodeExamples || 10,
    rtl: options.rtl || false,
  };

  const doc = new jsPDF({ unit: "mm", format: "a4" });
  const theme = PDF_THEMES[opts.theme as keyof typeof PDF_THEMES];

  // Set document properties
  doc.setProperties({
    title: data.meta.title,
    author: data.meta.author,
    subject: "Technical Portfolio",
    creator: "Portfolio Generator",
  });

  // Page dimensions
  const pageWidth = 210;
  const pageHeight = 297;
  const margins = { x: 20, y: 20, right: 20, bottom: 20 };
  const contentWidth = pageWidth - margins.x - margins.right;
  let currentY = margins.y;

  // Helper function to add text with word wrapping
  const addText = (
    text: string,
    x: number,
    y: number,
    maxWidth: number,
    fontSize: number = 10,
    fontStyle: string = "normal"
  ) => {
    doc.setFontSize(fontSize);
    doc.setFont("helvetica", fontStyle);
    const lines = doc.splitTextToSize(text, maxWidth);
    doc.text(lines, x, y);
    return y + lines.length * fontSize * 0.4;
  };

  // Helper function to add section header
  const addSectionHeader = (title: string, y: number): number => {
    currentY = y + 8;
    doc.setFillColor(...theme.accent);
    doc.rect(margins.x, currentY - 2, 4, 4, "F");
    currentY = addText(
      title,
      margins.x + 8,
      currentY,
      contentWidth - 8,
      14,
      "bold"
    );
    doc.setDrawColor(...theme.accent);
    doc.setLineWidth(0.5);
    doc.line(margins.x, currentY + 2, pageWidth - margins.right, currentY + 2);
    return currentY + 6;
  };

  // Helper function to add code block
  const addCodeBlock = (code: string, y: number, maxWidth: number): number => {
    const codeLines = code.split("\n");
    const lineHeight = 3.5;
    const padding = 2;
    const startY = y + 2;

    // Draw code background
    doc.setFillColor(240, 240, 240);
    doc.rect(
      margins.x + padding,
      startY - padding,
      maxWidth - 2 * padding,
      codeLines.length * lineHeight + 2 * padding,
      "F"
    );

    // Draw code border
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.3);
    doc.rect(
      margins.x + padding,
      startY - padding,
      maxWidth - 2 * padding,
      codeLines.length * lineHeight + 2 * padding,
      "S"
    );

    // Add code text
    doc.setFontSize(8);
    doc.setFont("courier", "normal");
    let codeY = startY;
    codeLines.forEach((line) => {
      doc.text(line, margins.x + padding + 1, codeY);
      codeY += lineHeight;
    });

    return codeY + 4;
  };

  // Helper function to check if we need a new page
  const checkNewPage = (requiredSpace: number): boolean => {
    return currentY + requiredSpace > pageHeight - margins.bottom;
  };

  const addNewPage = () => {
    doc.addPage();
    currentY = margins.y;
  };

  // Title Page
  currentY = addSectionHeader(data.meta.title, currentY);
  currentY = addText(
    `Generated by ${data.meta.author}`,
    margins.x,
    currentY,
    contentWidth,
    12
  );
  currentY = addText(
    `Version ${data.meta.version} • ${new Date(
      data.meta.generatedAt
    ).toLocaleDateString()}`,
    margins.x,
    currentY,
    contentWidth,
    10
  );
  currentY += 10;

  // Table of Contents
  if (data.projects.length > 0) {
    currentY = addSectionHeader("Table of Contents", currentY);
    currentY = addText(
      "Projects",
      margins.x,
      currentY,
      contentWidth,
      12,
      "bold"
    );
    data.projects.slice(0, opts.maxProjects).forEach((project, index) => {
      currentY = addText(
        `${index + 1}. ${project.name}`,
        margins.x + 10,
        currentY,
        contentWidth - 10,
        10
      );
    });
    currentY += 5;
  }

  // Projects Section
  if (data.projects.length > 0) {
    if (checkNewPage(50)) addNewPage();
    currentY = addSectionHeader("Featured Projects", currentY);

    data.projects.slice(0, opts.maxProjects).forEach((project) => {
      if (checkNewPage(100)) addNewPage();

      // Project header
      currentY = addText(
        project.name,
        margins.x,
        currentY,
        contentWidth,
        14,
        "bold"
      );
      currentY = addText(
        project.description,
        margins.x,
        currentY,
        contentWidth,
        10
      );

      // Technologies
      if (project.technologies.length > 0) {
        currentY += 2;
        currentY = addText(
          `Technologies: ${project.technologies.join(", ")}`,
          margins.x,
          currentY,
          contentWidth,
          9,
          "italic"
        );
      }

      // Architecture overview
      if (project.architecture.overview) {
        currentY += 4;
        currentY = addText(
          "Architecture:",
          margins.x,
          currentY,
          contentWidth,
          10,
          "bold"
        );
        currentY = addText(
          project.architecture.overview,
          margins.x + 5,
          currentY,
          contentWidth - 5,
          9
        );
      }

      // Technical challenges for this project
      if (opts.includeChallenges && project.technicalChallenges.length > 0) {
        currentY += 4;
        currentY = addText(
          "Technical Challenges:",
          margins.x,
          currentY,
          contentWidth,
          10,
          "bold"
        );
        project.technicalChallenges.forEach((challenge) => {
          currentY = addText(
            `• ${challenge.title}`,
            margins.x + 5,
            currentY,
            contentWidth - 5,
            9,
            "bold"
          );
          currentY = addText(
            `  Problem: ${challenge.problem}`,
            margins.x + 10,
            currentY,
            contentWidth - 10,
            8
          );
          currentY = addText(
            `  Solution: ${challenge.solution}`,
            margins.x + 10,
            currentY,
            contentWidth - 10,
            8
          );
          currentY = addText(
            `  Impact: ${challenge.impact}`,
            margins.x + 10,
            currentY,
            contentWidth - 10,
            8
          );
          currentY += 2;
        });
      }

      // Code examples for this project
      if (opts.includeCodeExamples && project.codeExamples.length > 0) {
        currentY += 4;
        currentY = addText(
          "Code Examples:",
          margins.x,
          currentY,
          contentWidth,
          10,
          "bold"
        );
        project.codeExamples.slice(0, 2).forEach((example) => {
          currentY = addText(
            `${example.title}`,
            margins.x + 5,
            currentY,
            contentWidth - 5,
            9,
            "bold"
          );
          currentY = addText(
            example.description,
            margins.x + 5,
            currentY,
            contentWidth - 5,
            8
          );
          currentY = addCodeBlock(example.code, currentY, contentWidth - 5);
          currentY = addText(
            example.explanation,
            margins.x + 5,
            currentY,
            contentWidth - 5,
            8,
            "italic"
          );
          currentY += 3;
        });
      }

      currentY += 8;
    });
  }

  // Standalone Code Examples Section
  if (opts.includeCodeExamples && data.codeExamples.length > 0) {
    if (checkNewPage(50)) addNewPage();
    currentY = addSectionHeader("Code Examples", currentY);

    data.codeExamples.slice(0, opts.maxCodeExamples).forEach((example) => {
      if (checkNewPage(80)) addNewPage();

      currentY = addText(
        `${example.title} (${example.project})`,
        margins.x,
        currentY,
        contentWidth,
        12,
        "bold"
      );
      currentY = addText(
        example.description,
        margins.x,
        currentY,
        contentWidth,
        9
      );
      currentY = addCodeBlock(example.code, currentY, contentWidth);
      currentY = addText(
        example.explanation,
        margins.x,
        currentY,
        contentWidth,
        8,
        "italic"
      );
      currentY += 6;
    });
  }

  // Technical Challenges Section
  if (opts.includeChallenges && data.technicalChallenges.length > 0) {
    if (checkNewPage(50)) addNewPage();
    currentY = addSectionHeader("Technical Challenges & Solutions", currentY);

    data.technicalChallenges.forEach((challenge, index) => {
      if (checkNewPage(60)) addNewPage();

      currentY = addText(
        `${index + 1}. ${challenge.title}`,
        margins.x,
        currentY,
        contentWidth,
        11,
        "bold"
      );
      if (challenge.project) {
        currentY = addText(
          `Project: ${challenge.project}`,
          margins.x,
          currentY,
          contentWidth,
          9,
          "italic"
        );
      }
      currentY = addText(
        `Problem: ${challenge.problem}`,
        margins.x + 5,
        currentY,
        contentWidth - 5,
        9
      );
      currentY = addText(
        `Solution: ${challenge.solution}`,
        margins.x + 5,
        currentY,
        contentWidth - 5,
        9
      );
      currentY = addText(
        `Impact: ${challenge.impact}`,
        margins.x + 5,
        currentY,
        contentWidth - 5,
        9
      );
      if (challenge.technologies.length > 0) {
        currentY = addText(
          `Technologies: ${challenge.technologies.join(", ")}`,
          margins.x + 5,
          currentY,
          contentWidth - 5,
          8,
          "italic"
        );
      }
      currentY += 6;
    });
  }

  // Architecture Decisions Section
  if (opts.includeArchitecture && data.architecture.length > 0) {
    if (checkNewPage(50)) addNewPage();
    currentY = addSectionHeader("Architecture Decisions", currentY);

    data.architecture.forEach((decision, index) => {
      if (checkNewPage(40)) addNewPage();

      currentY = addText(
        `${index + 1}. ${decision.title}`,
        margins.x,
        currentY,
        contentWidth,
        11,
        "bold"
      );
      currentY = addText(
        `Context: ${decision.context}`,
        margins.x + 5,
        currentY,
        contentWidth - 5,
        9
      );
      currentY = addText(
        `Decision: ${decision.decision}`,
        margins.x + 5,
        currentY,
        contentWidth - 5,
        9
      );
      if (decision.consequences.length > 0) {
        currentY = addText(
          `Consequences: ${decision.consequences.join(", ")}`,
          margins.x + 5,
          currentY,
          contentWidth - 5,
          8
        );
      }
      currentY += 4;
    });
  }

  return doc;
}
